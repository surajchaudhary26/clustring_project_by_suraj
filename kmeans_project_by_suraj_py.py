# -*- coding: utf-8 -*-
"""Kmeans_project_by_suraj.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12WM0h-j7XgxJBjzhVDp8yhFq5BzInHIp

importing dependencies
"""



import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.cluster import KMeans



"""Data collection and analysis"""

# loading data from csv file to pandas dataframe
df = pd.read_csv('/content/customer_churn.csv')
# loading data from csv file to pandas dataframe
# df = pd.read_csv('/content/mall_customers_data.csv')

"""show first 5 row in data frame

"""

df.head()

df.shape

# information about dataset

df.info()

df.isnull().sum().sum()

# if we do have missing value we use method like imputation to replace with suitable value

# #  we need these to columns { Annual Income (k$)	, Spending Score (1-100 }

# X = df.iloc[:,[3,4]].values

"""choosing the number of clusters

"""

df.duplicated().sum()

for col in df.columns:
  if(df[col].dtype!='object'):
    sns.boxplot(df[col])
    plt.title(col)
    plt.show()

from sklearn.preprocessing import LabelEncoder

le=LabelEncoder()  #label endoing used to assign unique integer values to the object values as ou rmodel is incapable of analysing the object(string) values

# df['gender']=le.fit_transform(df['gender'])  #male=1 female=0
for col in df.columns:
  df[col]=le.fit_transform(df[col])

df

df.info()

df_copy=df.copy()

df_copy.drop('customerID',axis=1,inplace=True)

df_copy

# from sklearn.preprocessing import StandardScaler

# sc=StandardScaler()

# df_scaled=sc.fit_transform(df_copy)

# df_scaled

# df_scaled_table=pd.DataFrame(df_scaled,columns=df_copy.columns)

# df_copy.columns

# df_scaled_table

from sklearn.cluster import KMeans

model = KMeans(n_clusters=3)

model.fit(df_copy)

model.labels_

df['Clusters']=model.labels_

df

n=[2,3,4,5,6,7,8,9,10]

ssd=[]
for k in n:
  temp_model=KMeans(n_clusters=k,max_iter=150,random_state=32)
  temp_model.fit(df_copy)
  ssd.append(temp_model.inertia_) #sum of squared distances between each data point and its assigned cluster centroid

ssd

plt.plot(n,ssd)

final_model=KMeans(n_clusters=4,max_iter=150,random_state=32)
final_model.fit(df_copy)

final_model.labels_

df['Clusters']=final_model.labels_

df

group1=df[df['Clusters']==0]
group1

group2=df[df['Clusters']==1]
group3=df[df['Clusters']==2]
group4=df[df['Clusters']==3]

df_short=df.iloc[:500,:]

df_short.shape

plt.figure(figsize=(10,6))
sns.scatterplot(data=df_short,x='TotalCharges',y='MonthlyCharges',hue='Clusters',palette='Set1',s=100)
plt.show()

import plotly.express as px

# Create a 3d scatter plot
fig = px.scatter_3d(df_short , x="TotalCharges" , y="MonthlyCharges" , z="tenure" ,color="Clusters" ,hover_name = "Clusters" , title ="3D Scatter plot of customer segmentation " )

# Update layout for better visulization

fig.update_layout( scene = dict( xaxis_title="TotalCharges" , yaxis_title="MonthlyCharges" , zaxis_title="Tenure"), width = 800 , height = 600)

fig.show()

